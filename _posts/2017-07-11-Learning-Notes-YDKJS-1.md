---
layout: post
title: 你不懂的JS学习笔记-1部分
category: LearingNote-YDKJS
---
# You don't KnowJS
> 引语：十分感谢React中文社区开源群的以为管理员大大给我推荐的[你不懂的JS](https://github.com/getify/You-Dont-Know-JS)这本书，网上有许多开源人士都参与了翻译这本书，再次十分感谢。这里记录一下学习书的笔记，***个人理解仅供参考，真正的学习还需要读原著，如有改正和探讨谢谢指出***
# 第一部分:作用域和闭包
## 第一章
### 编译的三个步骤 >p5
1. 分词/词法分析:通俗来说就是编译器会将程序猿写的代码首先拆分成可以进行编译的代码 
* eg：var a = 2；可以被编译器分割为var,a,=,2,;  
 格是否会被当作词法单元，取决于空格在 这门语言中是否具有意义。
2. 解析/语法分析  
* AST：[抽象语法树](https://tech.meituan.com/abstract-syntax-tree.html) 的概念，他会上述分割好的代码进组装成为一个语法树，而=，var ，a，2 都回变成语法树的节点。
3. 代码生成
* 编译器最终会将这样的AST语法树编译为可执行的底层代码。
* 特别要强调的是JS的引擎在编译器执行是会帮助编译器做代码优化，同通常来说他不会编译的过程就发生在引擎执行代码的前很短的时间，并不是像执行C/C++等这些代码需要先build完整个文件再进行run
### 理解作用域 >p7
1. 介绍以下三个关键的概念
* 编译器: 用来在引擎执行代码前提供给引擎代码 PS：我自己理解编译器就是一个给作用域介绍人的人 
* 引擎：用来负责执行和编译的环境 PS：我自己理解引擎就是一个想作用域查询认识谁的人
* 作用域：负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。PS：我自己理解作用域就是一个人是很多变量的东西
* LHS和RHS：“赋值操作的目标是谁(LHS)”以及“谁是赋值操作的源头
(RHS)”。PS：理解为引擎的动作  
一般来说函数的调用是RHS理解为 谁用他： 例如：console.log(1)就是谁用1  
LHS可以理解为 他给谁 例如：a = 2； 2应该给谁   
如果是 console.log（a）应该就是RHS和LHS一起  

### 3.引擎和作用域的对话P9
* 对话中console是个内置对象很关键 ps:我理解的就是他是全局作用域
* 测验的答案：LHS：foo=》c，2=》a，a=》b    ps：谁要给谁
* 测试的答案：RHS：2=》foo，a=》foo，b=》a，a+b=》return ps：睡给谁

### 4.作用域的嵌套P10
* 作用域的嵌套：ps：可以理解为作用域是个家族，爸爸认识儿子的人，爷爷认识爸爸认识的人，每次问儿子没有问爸爸。
* ReferenceError：你找了作用域大家族都不认识的人就会出错

### 5.小结
* 如果查找的目的是对
变量进行赋值，那么就会使用 LHS 查询;如果目的是获取变量的值，就会使用 RHS 查询

# 第二章
### 1.词法阶段
* 普通作用域和动态作用域
* 一个词法不可能同时在两个作用域中
* 作用域查找会在找到第一个匹配的标识符时停止
* 全局变量会自动成为全局对象(比如浏览器中的 window 对象，node的global)的属性
* 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定。

### 2. 欺骗词法P18
* eval函数:接受字符串代码他会在编译器执行在引擎快要执行的时候将这段代码写在他位于的位置
* 在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其 中的声明无法修改所在的作用域。
* with函数:
```
var obj = { a: 1,
b: 2,
c: 3 };
// 单调乏味的重复 "obj" obj.a = 2;
obj.b = 3;
obj.c = 4;
// 简单的快捷方式 with (obj) {
         a = 3;
         b = 4;
         c = 5;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function foo(obj) { with (obj) {
a = 2; }
}
var o1 = { a: 3
};
var o2 = { b: 3
};
     foo( o1 );
     console.log( o1.a ); // 2
foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2——不好，a 被泄漏到全局作用域上了!
```
* with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对 象的属性也会被处理为定义在这个作用域中的词法标识符。(非严格模式)

# 第三章
### 函数中的作用域
* bar(..) 拥有自己的作用域气泡。全局作用域也有自己的作用域气泡，它只包含了一个标 识符:foo。相关代码P23

### 函数作用域
* 虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。首先， 必须声明一个具名函数 foo()，意味着 foo 这个名称本身“污染”了所在作用域(在这个 例子中是全局作用域)。其次，必须显式地通过函数名(foo())调用这个函数才能运行其 中的代码。

```
//并不理想
function foo() { // <-- 添加这一行
var a = 3; console.log( a ); // 3
} // <-- 以及这一行 foo(); // <-- 以及这一行
//方法1：
(function foo(){ // <-- 添加这一行 var a = 3;
console.log( a ); // 3 })(); // <-- 以及这一行
```
* 首先，包装函数的声明以 (function... 而不仅是以 function... 开始。尽管看上去这并不 是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一 个标准的函数声明来处理。  
# ************* P27 有问题 ****************

### 匿名函数
* 编写带有名字的函数便于理解
```
setTimeout( function timeoutHandler() { // <-- 快看，我有名字了! console.log( "I waited 1 second!" );
}, 1000 );
```
* function 和 var 编译时存在函数的提升，也就是说var 和 function会优先的被编译器识别交给作用域。[这里](https://my.oschina.net/u/2331760/blog/468672)

```
fnc();
function fnc(){
...
}//正常，因为了函数声明提升，函数调用可在函数声明之前
fnc();
var fnc=function(){
    ...
}//报错，变量fnc还未保存对函数的引用，函数调用必须在函数表达式之后。
function fnc(){
    ...
}();//报错，javascript引擎执行到此会略过函数声明而执行(),所以会报错。
function(){
    ...
}();//报错
```
* {}无法创建块作用域，但是try{}catch{}却可以